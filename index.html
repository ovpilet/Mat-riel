<script>
// Encapsulation de toute la logique dans une IIFE (Immediately Invoked Function Expression)
// pour éviter de polluer l'espace de nom global.
(function() {
    'use strict';

    // --- CONFIGURATION ---
    const GOOGLE_APPS_SCRIPT_API_URL = 'https://script.google.com/macros/s/AKfycbxeYItICJG8R31TnsgMTlhoed9bhp5lnaa-9cqAH933deMxb1NlhBE_fsNaCMfp4pu8/exec';

    // --- ÉTAT DE L'APPLICATION ---
    // La "source de vérité" de notre application. Le DOM sera une simple réflexion de cet état.
    const state = {
        reservations: [],
        articles: {},
        noms: [],
        isLoading: false,
        hasUnsavedChanges: false,
    };

    // --- SÉLECTEURS DOM ---
    const dom = {
        loader: document.getElementById('loader'),
        tableBody: document.getElementById('tableBody'),
        placeholder: document.getElementById('placeholder'),
        addBtn: document.getElementById('addReservationBtn'),
        saveBtn: document.getElementById('saveBtn'),
        messageBox: document.getElementById('messageBox'),
        calendarModal: document.getElementById('calendarModal'),
        closeCalendarModalBtn: document.getElementById('closeCalendarModal'),
        calendarEl: document.getElementById('calendar'),
        existingNamesDatalist: document.getElementById('existing-names'),
    };
    
    // --- FONCTIONS DE RENDU (GÉNÉRATION DU HTML) ---

    /**
     * Peuple la datalist des noms pour l'autocomplétion.
     */
    function renderDatalists() {
        dom.existingNamesDatalist.innerHTML = ''; // Vider la liste existante
        state.noms.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            dom.existingNamesDatalist.appendChild(option);
        });
    }

    /**
     * Point d'entrée principal pour redessiner l'interface utilisateur.
     * Appelé à chaque fois que l'état change.
     */
    function render() {
        // Gérer l'état de chargement
        dom.loader.classList.toggle('hidden', !state.isLoading);
        dom.addBtn.disabled = state.isLoading;
        
        // Gérer le bouton de sauvegarde
        dom.saveBtn.disabled = !state.hasUnsavedChanges || state.isLoading;
        dom.saveBtn.innerHTML = state.isLoading 
            ? `<span>Enregistrement...</span>`
            : `<svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M4.5 12.75l6 6 9-13.5"></path></svg><span>Enregistrer</span>`;

        // Vider le tableau
        dom.tableBody.innerHTML = '';
        
        // Afficher un message si aucune réservation
        dom.placeholder.classList.toggle('hidden', state.reservations.length > 0);
        
        // Mettre à jour les listes pour l'autocomplétion
        renderDatalists();
        
        // Rendre chaque ligne de réservation
        state.reservations.forEach(res => {
            const row = document.createElement('tr');
            row.id = res.id;
            row.className = res.hasConflict ? 'conflict-warning' : '';
            row.innerHTML = `
                <td data-label="Nom(s)">
                    <div class="sub-item-list">${res.names.map((name, index) => renderNameInput(res.id, index, name)).join('')}</div>
                    <button class="btn-add-subitem text-xs text-blue-600 hover:text-blue-800 font-semibold" data-action="add-name" data-res-id="${res.id}">+ Ajouter un nom</button>
                </td>
                <td data-label="Date Départ"><input type="date" value="${res.startDate}" data-action="update-date" data-field="startDate" data-res-id="${res.id}"></td>
                <td data-label="Date Retour"><input type="date" value="${res.endDate}" data-action="update-date" data-field="endDate" data-res-id="${res.id}"></td>
                <td data-label="Articles">
                    <div class="sub-item-list">${res.articles.map((article, index) => renderArticleInput(res.id, index, article)).join('')}</div>
                    <button class="btn-add-subitem text-xs text-blue-600 hover:text-blue-800 font-semibold" data-action="add-article" data-res-id="${res.id}">+ Ajouter un article</button>
                </td>
                <td data-label="Actions" class="text-center">
                    <button class="btn-icon" data-action="delete-reservation" data-res-id="${res.id}" aria-label="Supprimer la réservation">
                        <svg class="w-6 h-6 text-gray-400 hover:text-red-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.56 0c.342.052.682.107 1.022.166m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 00-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 00-7.5 0"></path></svg>
                    </button>
                </td>
            `;
            dom.tableBody.appendChild(row);
        });
    }

    function renderNameInput(resId, index, name) {
        return `
            <div>
                <input type="text" list="existing-names" value="${name}" data-action="update-name" data-res-id="${resId}" data-index="${index}" placeholder="Nom du contact">
                <button class="btn-icon" data-action="remove-name" data-res-id="${resId}" data-index="${index}" aria-label="Supprimer ce nom">
                    <svg class="w-5 h-5 text-gray-400 hover:text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        `;
    }

    function renderArticleInput(resId, index, article) {
        const categoriesOptions = Object.keys(state.articles).map(cat => `<option value="${cat}" ${cat === article.category ? 'selected' : ''}>${cat}</option>`).join('');
        const itemsOptions = (state.articles[article.category] || []).map(item => `<option value="${item}" ${item === article.name ? 'selected' : ''}>${item}</option>`).join('');
        return `
            <div>
                <select data-action="update-article-category" data-res-id="${resId}" data-index="${index}">
                    <option value="">-- Catégorie --</option>
                    ${categoriesOptions}
                </select>
                <select data-action="update-article-name" data-res-id="${resId}" data-index="${index}" ${!article.category ? 'disabled' : ''}>
                    <option value="">-- Article --</option>
                    ${itemsOptions}
                </select>
                <button class="btn-icon" data-action="remove-article" data-res-id="${resId}" data-index="${index}" aria-label="Supprimer cet article">
                    <svg class="w-5 h-5 text-gray-400 hover:text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
        `;
    }
    
    // --- GESTION DES ÉVÉNEMENTS (EVENT HANDLING) ---
    
    function initEventListeners() {
        dom.addBtn.addEventListener('click', handleAddReservation);
        dom.saveBtn.addEventListener('click', handleSave);

        // Délégation d'événements sur le corps du tableau
        dom.tableBody.addEventListener('change', handleTableChange);
        dom.tableBody.addEventListener('click', handleTableClick);
        dom.tableBody.addEventListener('input', handleTableInput);
    }

    function handleAddReservation() {
        const newReservation = {
            id: `temp-${Date.now()}`,
            names: [''],
            startDate: new Date().toISOString().split('T')[0],
            endDate: new Date().toISOString().split('T')[0],
            articles: [{ category: '', name: '' }],
            hasConflict: false
        };
        state.reservations.unshift(newReservation);
        markAsDirty();
        render();
    }
    
    function handleTableChange(e) {
        const target = e.target;
        const action = target.dataset.action;
        if (!action) return;
        
        const resId = target.dataset.resId;
        const res = state.reservations.find(r => r.id === resId);
        if (!res) return;

        switch(action) {
            case 'update-date':
                res[target.dataset.field] = target.value;
                break;
            case 'update-article-category':
                res.articles[target.dataset.index].category = target.value;
                res.articles[target.dataset.index].name = ''; 
                break;
            case 'update-article-name':
                res.articles[target.dataset.index].name = target.value;
                break;
        }
        
        markAsDirty();
        checkForConflicts();
        render();
    }
    
    function handleTableClick(e) {
        const button = e.target.closest('button');
        if (!button) return;
        const action = button.dataset.action;
        if (!action) return;
        
        const resId = button.dataset.resId;
        const res = state.reservations.find(r => r.id === resId);
        if (!res) return;
        
        const index = parseInt(button.dataset.index, 10);

        switch(action) {
            case 'add-name': res.names.push(''); break;
            case 'remove-name': res.names.splice(index, 1); break;
            case 'add-article': res.articles.push({ category: '', name: '' }); break;
            case 'remove-article': res.articles.splice(index, 1); break;
            case 'delete-reservation': state.reservations = state.reservations.filter(r => r.id !== resId); break;
        }

        markAsDirty();
        checkForConflicts();
        render();
    }
    
    function handleTableInput(e) {
        const target = e.target;
        if (target.dataset.action !== 'update-name') return;
        
        const resId = target.dataset.resId;
        const index = parseInt(target.dataset.index, 10);
        const res = state.reservations.find(r => r.id === resId);
        if (!res) return;
        
        res.names[index] = target.value;
        markAsDirty();
    }

    // --- LOGIQUE MÉTIER & API ---

    function markAsDirty() {
        if (!state.hasUnsavedChanges) {
            state.hasUnsavedChanges = true;
            render();
        }
    }

    async function handleSave() {
        state.isLoading = true;
        render();

        if (checkForConflicts(true)) {
            state.isLoading = false;
            render();
            return;
        }

        const payload = state.reservations.map(({ id, hasConflict, ...rest }) => rest);
        const result = await postApiData('saveReservations', payload);
        
        if (result !== null) {
            showMessage('Modifications enregistrées avec succès !', 'success');
            state.hasUnsavedChanges = false;
        } else {
            showMessage("Erreur lors de l'enregistrement.", 'error');
        }
        
        state.isLoading = false;
        await loadInitialData();
    }

    function checkForConflicts(showAlert = false) {
        let conflictFound = false;
        const articleReservations = new Map();

        state.reservations.forEach(r => r.hasConflict = false);

        state.reservations.forEach(res => {
            res.articles.forEach(article => {
                if (!article.name || !res.startDate || !res.endDate) return;
                const key = `${article.category}-${article.name}`;
                if (!articleReservations.has(key)) {
                    articleReservations.set(key, []);
                }
                articleReservations.get(key).push({
                    id: res.id,
                    start: new Date(res.startDate),
                    end: new Date(res.endDate)
                });
            });
        });

        for (const [articleKey, reservations] of articleReservations.entries()) {
            for (let i = 0; i < reservations.length; i++) {
                for (let j = i + 1; j < reservations.length; j++) {
                    const r1 = reservations[i];
                    const r2 = reservations[j];

                    if (r1.start <= r2.end && r2.start <= r1.end) {
                        conflictFound = true;
                        const res1 = state.reservations.find(r => r.id === r1.id);
                        const res2 = state.reservations.find(r => r.id === r2.id);
                        if(res1) res1.hasConflict = true;
                        if(res2) res2.hasConflict = true;
                    }
                }
            }
        }
        
        if (conflictFound && showAlert) {
            showMessage(`Conflit détecté ! Un ou plusieurs articles sont réservés sur les mêmes dates.`, 'error', 5000);
        }
        return conflictFound;
    }
    
    // --- COMMUNICATIONS API ---

    async function fetchApiData(action) {
        try {
            const response = await fetch(`${GOOGLE_APPS_SCRIPT_API_URL}?action=${action}`);
            if (!response.ok) throw new Error(`Erreur HTTP : ${response.status}`);
            const result = await response.json();
            if (result.status !== 200) throw new Error(`Erreur API : ${result.message || 'Inconnue'}`);
            return result.data;
        } catch (error) {
            showMessage(`Erreur de chargement (${action}): ${error.message}`, 'error');
            return null;
        }
    }

    async function postApiData(action, payload) {
        try {
            const response = await fetch(`${GOOGLE_APPS_SCRIPT_API_URL}?action=${action}`, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain;charset=utf-8' },
                body: JSON.stringify(payload),
            });
            if (!response.ok) throw new Error(`Erreur HTTP : ${response.status}`);
            const result = await response.json();
            if (result.status !== 200) throw new Error(`Erreur API : ${result.message || 'Inconnue'}`);
            return result.data;
        } catch (error) {
            showMessage(`Erreur d'enregistrement (${action}): ${error.message}`, 'error');
            return null;
        }
    }
    
    // --- UTILITAIRES ---
    
    function showMessage(text, type = 'success', duration = 3000) {
        dom.messageBox.textContent = text;
        dom.messageBox.className = 'message-box show';
        dom.messageBox.classList.add(type);
        setTimeout(() => {
            dom.messageBox.classList.remove('show');
        }, duration);
    }
    
    // --- INITIALISATION ---

    async function loadInitialData() {
        state.isLoading = true;
        render();

        const [namesData, articlesData, reservationsData] = await Promise.all([
            fetchApiData('getNames'),
            fetchApiData('getArticles'),
            fetchApiData('getReservations')
        ]);
        
        state.noms = namesData?.names || [];
        state.articles = articlesData?.articles || {};

        state.reservations = (reservationsData?.reservations || []).map((res, i) => ({
            ...res,
            id: `res-${Date.now()}-${i}`,
            hasConflict: false
        }));

        state.isLoading = false;
        state.hasUnsavedChanges = false;
        checkForConflicts();
        render();
    }

    // --- Point d'entrée de l'application ---
    document.addEventListener('DOMContentLoaded', () => {
        initEventListeners();
        loadInitialData();
    });

})();
</script>